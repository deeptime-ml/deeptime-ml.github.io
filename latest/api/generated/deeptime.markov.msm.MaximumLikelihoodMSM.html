
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>class MaximumLikelihoodMSM &#8212; deeptime 0.2.9 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/perfect-scrollbar/css/perfect-scrollbar.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/perfect-scrollbar/js/perfect-scrollbar.min.js"></script>
    <script src="../../_static/perfect-scrollbar/js/perfect-scrollbar.min.js"></script>
    <script src="../../_static/d3.v5.min.js"></script>
    <script src="../../_static/d3-legend.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"></script>
    <script src="../../_static/katex_autorenderer.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="class BayesianMSM" href="deeptime.markov.msm.BayesianMSM.html" />
    <link rel="prev" title="deeptime.markov" href="../index_markov.html" />
<link rel="apple-touch-icon" sizes="180x180" href="../../_static/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../_static/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../_static/favicon-16x16.png">
<link rel="manifest" href="../../_static/site.webmanifest">

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo/deeptime_romand_white.svg" alt="Logo"/>
    
  </a>
</p>










<!-- h3>Navigation</h3 -->
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index_dimreduction.html">Dimension reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_deepdimreduction.html">Deep dim reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/sindy.html">SINDy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_msm.html">Markov state models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/hmm.html">Hidden Markov Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/clustering.html">Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datasets/index.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_dev.html">For developers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index_base.html">deeptime.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_clustering.html">deeptime.clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_sindy.html">deeptime.sindy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_covariance.html">deeptime.covariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_decomposition.html">deeptime.decomposition</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index_markov.html">deeptime.markov</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index_markov.html#estimators">Estimators</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#"><em>class</em> MaximumLikelihoodMSM</a></li>
<li class="toctree-l3"><a class="reference internal" href="deeptime.markov.msm.BayesianMSM.html"><em>class</em> BayesianMSM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#analysis-tools">Analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#utilities-and-alternatives">Utilities and alternatives</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../index_markov_hmm.html">deeptime.markov.hmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_markov_tools.html">deeptime.markov.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_basis.html">deeptime.basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_kernels.html">deeptime.kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_data.html">deeptime.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_numeric.html">deeptime.numeric</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_util.html">deeptime.util</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../imprint.html">Imprint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">Software License</a></li>
</ul>





<!--
<p>
    <iframe src="https://ghbtns.com/github-btn.html?user=deeptime-ml&repo=deeptime&type=star&count=true&size=large&v=2"
            allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>
--><p class="caption">
    <span class="caption-text">Version</span>
</p>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" id="version-latest"
           href="../latest/../../index.html">Latest release
            (0.2.9)</a>
    </li>
    <li class="toctree-l1">
        <a class="reference internal" id="version-trunk"
           href="../trunk/../../index.html">Trunk version</a>
    </li>
</ul>
<script>
    if (window.location.href.indexOf("latest") > -1) {
        document.getElementById("version-latest").className = "reference internal current";
        document.getElementById("version-trunk").className = "reference internal";
    } else {
        document.getElementById("version-latest").className = "reference internal";
        document.getElementById("version-trunk").className = "reference internal current";
    }
</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index_markov.html">deeptime.markov</a><ul>
      <li>Previous: <a href="../index_markov.html" title="previous chapter">deeptime.markov</a></li>
      <li>Next: <a href="deeptime.markov.msm.BayesianMSM.html" title="next chapter"><em>class</em> BayesianMSM</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Quick search" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><div class="github-wrapper">
    <a href="https://github.com/deeptime-ml/deeptime"
       style="width: 16rem; height:100%; position:absolute; top:0; left:0;">
        <img class="side-logo logo-github" src="../../_static/GitHub-Mark-Light-32px.png" alt="gh"/>
        <div style="display: table; height: 100%; overflow: hidden;">
            <div style="display: table-cell; vertical-align: middle;">
                <div>deeptime &#64; GitHub
                </div>
            </div>
        </div>
    </a>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="class-maximumlikelihoodmsm">
<h1><em>class</em> MaximumLikelihoodMSM<a class="headerlink" href="#class-maximumlikelihoodmsm" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">deeptime.markov.msm.</span></span><span class="sig-name descname"><span class="pre">MaximumLikelihoodMSM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stationary_distribution_constraint</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_disconnected</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1000000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxerr</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity_threshold</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrix_tolerance</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lagtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum likelihood estimator for MSMs (<a class="reference internal" href="deeptime.markov.msm.MarkovStateModel.html#deeptime.markov.msm.MarkovStateModel" title="deeptime.markov.msm.MarkovStateModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovStateModel</span></code></a>)
given discrete trajectories or statistics thereof. This estimator produces instances of MSMs in form of
MSM collections (<a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html#deeptime.markov.msm.MarkovStateModelCollection" title="deeptime.markov.msm.MarkovStateModelCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovStateModelCollection</span></code></a>) which contain as many MSMs as there are connected
sets in the counting. A collection of MSMs per default behaves exactly like an ordinary MSM model on the largest
connected set. The connected set can be switched, changing the state of the collection to be have like an MSM on
the selected state subset.</p>
<p>Implementation according to <a class="footnote-reference brackets" href="#wu2020variational" id="id1">1</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reversible</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If true compute reversible MarkovStateModel, else non-reversible MarkovStateModel</p></li>
<li><p><strong>stationary_distribution_constraint</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Stationary vector on the full set of states. Estimation will be made such the the resulting transition
matrix has this distribution as an equilibrium distribution. Set probabilities to zero if the states which
should be excluded from the analysis.</p></li>
<li><p><strong>sparse</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – If true compute count matrix, transition matrix and all derived quantities using sparse matrix algebra.
In this case python sparse matrices will be returned by the corresponding functions instead of numpy arrays.
This behavior is suggested for very large numbers of states (e.g. &gt; 4000) because it is likely to be much
more efficient.</p></li>
<li><p><strong>allow_disconnected</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – If set to true, the resulting transition matrix may have disconnected and transient states, and the
estimated stationary distribution is only meaningful on the respective connected sets.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=1000000</em>) – Optional parameter with reversible = True, sets the maximum number of iterations before the transition
matrix estimation method exits.</p></li>
<li><p><strong>maxerr</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default = 1e-8</em>) – Optional parameter with reversible = True. Convergence tolerance for transition matrix estimation. This
specifies the maximum change of the Euclidean norm of relative stationary probabilities
(<span class="math">\(x_i = \sum_k x_{ik}\)</span>). The relative stationary probability changes
<span class="math">\(e_i = (x_i^{(1)} - x_i^{(2)})/(x_i^{(1)} + x_i^{(2)})\)</span> are used in order to track changes in small
probabilities. The Euclidean norm of the change vector, <span class="math">\(|e_i|_2\)</span>, is compared to maxerr.</p></li>
<li><p><strong>transition_matrix_tolerance</strong> (<em>float</em><em>, </em><em>default=1e-8</em>) – The tolerance under which a matrix is still considered a transition matrix (only non-negative elements and
row sums of 1).</p></li>
<li><p><strong>connectivity_threshold</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.</em>) – Number of counts required to consider two states connected.</p></li>
<li><p><strong>lagtime</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Optional lagtime that can be provided at estimator level if fitting from timeseries directly.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p><dl class="footnote brackets">
<dt class="label" id="wu2020variational"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. <em>Journal of Nonlinear Science</em>, 30(1):23–66, 2020.</p>
</dd>
</dl>
</p>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.allow_disconnected" title="deeptime.markov.msm.MaximumLikelihoodMSM.allow_disconnected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">allow_disconnected</span></code></a></p></td>
<td><p>If set to true, the resulting transition matrix may have disconnected and transient states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.has_model" title="deeptime.markov.msm.MaximumLikelihoodMSM.has_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_model</span></code></a></p></td>
<td><p>Property reporting whether this estimator contains an estimated model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.model" title="deeptime.markov.msm.MaximumLikelihoodMSM.model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model</span></code></a></p></td>
<td><p>Shortcut to <a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model" title="deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetch_model()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.reversible" title="deeptime.markov.msm.MaximumLikelihoodMSM.reversible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reversible</span></code></a></p></td>
<td><p>If true compute reversible MarkovStateModel, else non-reversible MarkovStateModel</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.sparse" title="deeptime.markov.msm.MaximumLikelihoodMSM.sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse</span></code></a></p></td>
<td><p>If true compute count matrix, transition matrix and all derived quantities using sparse matrix algebra.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.stationary_distribution_constraint" title="deeptime.markov.msm.MaximumLikelihoodMSM.stationary_distribution_constraint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stationary_distribution_constraint</span></code></a></p></td>
<td><p>The stationary distribution constraint that can either be None (no constraint) or constrains the count and transition matrices to states with positive stationary vector entries.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.chapman_kolmogorov_validator" title="deeptime.markov.msm.MaximumLikelihoodMSM.chapman_kolmogorov_validator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chapman_kolmogorov_validator</span></code></a>(…[, test_model])</p></td>
<td><p>Returns a Chapman-Kolmogorov validator based on this estimator and a test model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model" title="deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_model</span></code></a>()</p></td>
<td><p>Yields the most recent <a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html#deeptime.markov.msm.MarkovStateModelCollection" title="deeptime.markov.msm.MarkovStateModelCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovStateModelCollection</span></code></a> that was estimated.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(data, *args, **kw)</p></td>
<td><p>Fits a new markov state model according to data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_fetch" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit_fetch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_fetch</span></code></a>(data, **kwargs)</p></td>
<td><p>Fits the internal model on data and subsequently fetches it in one call.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_counts" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_from_counts</span></code></a>(counts)</p></td>
<td><p>Fits a model from counts in form of a (n, n) count matrix, a <code class="xref py py-class docutils literal notranslate"><span class="pre">TransitionCountModel</span></code> or an instance of <cite>TransitionCountEstimator</cite>, which has been fit on data previously.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_from_discrete_timeseries</span></code></a>(…[, count_mode])</p></td>
<td><p>Fits a model directly from discrete time series data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.get_params" title="deeptime.markov.msm.MaximumLikelihoodMSM.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</p></td>
<td><p>Get the parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.set_params" title="deeptime.markov.msm.MaximumLikelihoodMSM.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</p></td>
<td><p>Set the parameters of this estimator.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.chapman_kolmogorov_validator">
<span class="sig-name descname"><span class="pre">chapman_kolmogorov_validator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_metastable_sets</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mlags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_model</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="deeptime.markov.msm.MarkovStateModel.html#deeptime.markov.msm.MarkovStateModel" title="deeptime.markov.msm._markov_state_model.MarkovStateModel"><span class="pre">deeptime.markov.msm._markov_state_model.MarkovStateModel</span></a><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.chapman_kolmogorov_validator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Chapman-Kolmogorov validator based on this estimator and a test model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_metastable_sets</strong> (<em>int</em>) – Number of metastable sets to project the state space down to.</p></li>
<li><p><strong>mlags</strong> (<em>int</em><em> or </em><em>range</em><em> or </em><em>list</em>) – Multiple of lagtimes of the test_model to test against.</p></li>
<li><p><strong>test_model</strong> (<a class="reference internal" href="deeptime.markov.msm.MarkovStateModel.html#deeptime.markov.msm.MarkovStateModel" title="deeptime.markov.msm.MarkovStateModel"><em>MarkovStateModel</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – The model that is tested. If not provided, uses this estimator’s encapsulated model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>validator</strong> – The validator that can be fit on data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.markov.MembershipsChapmanKolmogorovValidator.html#deeptime.markov.MembershipsChapmanKolmogorovValidator" title="deeptime.markov.MembershipsChapmanKolmogorovValidator">markov.MembershipsChapmanKolmogorovValidator</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If test_model is None and this estimator has not been <a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> on data yet or the output model
    was not a discrete output model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model">
<span class="sig-name descname"><span class="pre">fetch_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html#deeptime.markov.msm.MarkovStateModelCollection" title="deeptime.markov.msm._markov_state_model.MarkovStateModelCollection"><span class="pre">deeptime.markov.msm._markov_state_model.MarkovStateModelCollection</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields the most recent <a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html#deeptime.markov.msm.MarkovStateModelCollection" title="deeptime.markov.msm.MarkovStateModelCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">MarkovStateModelCollection</span></code></a> that was estimated.
Can be None if fit was not called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – The most recent markov state model or None.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html#deeptime.markov.msm.MarkovStateModelCollection" title="deeptime.markov.msm.MarkovStateModelCollection">MarkovStateModelCollection</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits a new markov state model according to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov.TransitionCountModel"><em>TransitionCountModel</em></a><em> or </em><em>(</em><em>n</em><em>, </em><em>n</em><em>) </em><em>ndarray</em><em> or </em><em>discrete timeseries</em>) – <p>Input data, can either be <a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov.TransitionCountModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransitionCountModel</span></code></a> or
a 2-dimensional ndarray which is interpreted as count matrix or a discrete timeseries (or a list thereof)
directly.</p>
<p>In the case of a timeseries, a lagtime must be provided in the keyword arguments. In this case, also the
keyword argument “count_mode” can be used, which defaults to “sliding”.
See also <a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_from_discrete_timeseries()</span></code></a>.</p>
</p></li>
<li><p><strong>*args</strong> – Dummy parameters for scikit-learn compatibility.</p></li>
<li><p><strong>**kw</strong> – Parameters for scikit-learn compatibility and optionally lagtime if fitting with time series data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Reference to self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM" title="deeptime.markov.msm.MaximumLikelihoodMSM">MaximumLikelihoodMSM</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransitionCountModel</span></code></dt><dd><p>Transition count model</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransitionCountEstimator</span></code></dt><dd><p>Estimating transition count models from data</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>This example is demonstrating how to fit a Markov state model collection from data which decomposes into a
collection of two sets of states with corresponding transition matrices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">deeptime.markov.msm</span> <span class="kn">import</span> <span class="n">MarkovStateModel</span>  <span class="c1"># import MSM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msm1</span> <span class="o">=</span> <span class="n">MarkovStateModel</span><span class="p">([[</span><span class="mf">.7</span><span class="p">,</span> <span class="mf">.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">.3</span><span class="p">,</span> <span class="mf">.7</span><span class="p">]])</span>  <span class="c1"># create first MSM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msm2</span> <span class="o">=</span> <span class="n">MarkovStateModel</span><span class="p">([[</span><span class="mf">.9</span><span class="p">,</span> <span class="mf">.05</span><span class="p">,</span> <span class="mf">.05</span><span class="p">],</span> <span class="p">[</span><span class="mf">.3</span><span class="p">,</span> <span class="mf">.6</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.1</span><span class="p">,</span> <span class="mf">.8</span><span class="p">]])</span>  <span class="c1"># create second MSM</span>
</pre></div>
</div>
<p>Now, simulate a trajectory where the states of msm2 are shifted by a fixed number <cite>2</cite>, i.e., msm1 describes
states [0, 1] and msm2 describes states [2, 3, 4] in the generated trajectory.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">msm1</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">1000000</span><span class="p">),</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">msm2</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)])</span>  <span class="c1"># simulate trajectory</span>
</pre></div>
</div>
<p>Given the trajectory, we fit a collection of MSMs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MaximumLikelihoodMSM</span><span class="p">(</span><span class="n">reversible</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">lagtime</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fetch_model</span><span class="p">()</span>
</pre></div>
</div>
<p>The model behaves like a MSM on the largest connected set, but the behavior can be changed by selecting,
e.g., the second largest connected set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">state_symbols</span><span class="p">()</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># change to second largest connected set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">state_symbols</span><span class="p">()</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p>And this is all the models contained in the collection:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">n_connected_msms</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Alternatively, one can fit with a previously estimated count model (that can be restricted to a subset
of states):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">TransitionCountEstimator</span><span class="p">(</span><span class="n">lagtime</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">count_mode</span><span class="o">=</span><span class="s2">&quot;sliding&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">fetch_model</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">submodel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># select submodel with state symbols [0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msm</span> <span class="o">=</span> <span class="n">MaximumLikelihoodMSM</span><span class="p">(</span><span class="n">reversible</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">fetch_model</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msm</span><span class="o">.</span><span class="n">state_symbols</span><span class="p">()</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p>And this is the only model in the collection:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msm</span><span class="o">.</span><span class="n">n_connected_msms</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.fit_fetch">
<span class="sig-name descname"><span class="pre">fit_fetch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the internal model on data and subsequently fetches it in one call.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em>) – Data that is used to fit the model.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments to <a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit" title="deeptime.markov.msm.MaximumLikelihoodMSM.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The estimated model.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>model</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_counts">
<span class="sig-name descname"><span class="pre">fit_from_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counts</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span> </span><a class="reference internal" href="deeptime.markov.TransitionCountEstimator.html#deeptime.markov.TransitionCountEstimator" title="deeptime.markov._transition_counting.TransitionCountEstimator"><span class="pre">deeptime.markov._transition_counting.TransitionCountEstimator</span></a><span class="p"><span class="pre">,</span> </span><a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov._transition_counting.TransitionCountModel"><span class="pre">deeptime.markov._transition_counting.TransitionCountModel</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits a model from counts in form of a (n, n) count matrix, a <code class="xref py py-class docutils literal notranslate"><span class="pre">TransitionCountModel</span></code> or an instance
of <cite>TransitionCountEstimator</cite>, which has been fit on data previously.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>counts</strong> (<em>(</em><em>n</em><em>, </em><em>n</em><em>) </em><em>ndarray</em><em> or </em><a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov.TransitionCountModel"><em>TransitionCountModel</em></a><em> or </em><a class="reference internal" href="deeptime.markov.TransitionCountEstimator.html#deeptime.markov.TransitionCountEstimator" title="deeptime.markov.TransitionCountEstimator"><em>TransitionCountEstimator</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Reference to self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM" title="deeptime.markov.msm.MaximumLikelihoodMSM">MaximumLikelihoodMSM</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries">
<span class="sig-name descname"><span class="pre">fit_from_discrete_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discrete_timeseries</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lagtime</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count_mode</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'sliding'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fit_from_discrete_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits a model directly from discrete time series data. This type of data can either be a single
trajectory in form of a 1d integer numpy array or a list thereof.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>discrete_timeseries</strong> (<em>ndarray</em><em> or </em><em>list of ndarray</em>) – Discrete timeseries data.</p></li>
<li><p><strong>lagtime</strong> (<em>int</em>) – The lag time under which to estimate state transitions and ultimately also the transition matrix.</p></li>
<li><p><strong>count_mode</strong> (<em>str</em><em>, </em><em>default=&quot;sliding&quot;</em>) – The count mode to use for estimating transition counts. For maximum-likelihood estimation, the recommended
choice is “sliding”. If the MSM should be used for sampling in a
<a class="reference internal" href="deeptime.markov.msm.BayesianMSM.html#deeptime.markov.msm.BayesianMSM" title="deeptime.markov.msm.BayesianMSM"><code class="xref py py-class docutils literal notranslate"><span class="pre">BayesianMSM</span></code></a>, the recommended choice is “effective”, which yields
transition counts that are statistically uncorrelated. A description can be found
in <a class="footnote-reference brackets" href="#noe2015statistical" id="id2">2</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Reference to self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM" title="deeptime.markov.msm.MaximumLikelihoodMSM">MaximumLikelihoodMSM</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>params</strong> – Parameter names mapped to their values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mapping of string to any</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**params</strong> (<em>dict</em>) – Estimator parameters.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Estimator instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.allow_disconnected">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">allow_disconnected</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.allow_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>If set to true, the resulting transition matrix may have disconnected and transient states.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.has_model">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">has_model</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.has_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Property reporting whether this estimator contains an estimated model. This assumes that the model
is initialized with <cite>None</cite> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.model">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut to <a class="reference internal" href="#deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model" title="deeptime.markov.msm.MaximumLikelihoodMSM.fetch_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetch_model()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.reversible">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">reversible</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.reversible" title="Permalink to this definition">¶</a></dt>
<dd><p>If true compute reversible MarkovStateModel, else non-reversible MarkovStateModel</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.sparse">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">sparse</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>If true compute count matrix, transition matrix and all derived quantities using sparse matrix algebra.
In this case python sparse matrices will be returned by the corresponding functions instead of numpy arrays.
This behavior is suggested for very large numbers of states (e.g. &gt; 4000) because it is likely
to be much more efficient.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MaximumLikelihoodMSM.stationary_distribution_constraint">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">stationary_distribution_constraint</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[numpy.ndarray]</span></em><a class="headerlink" href="#deeptime.markov.msm.MaximumLikelihoodMSM.stationary_distribution_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>The stationary distribution constraint that can either be None (no constraint) or constrains the
count and transition matrices to states with positive stationary vector entries.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter</dt>
<dd class="field-odd"><p>Yields the currently configured constraint vector, can be None.</p>
</dd>
<dt class="field-even">Setter</dt>
<dd class="field-even"><p>Sets a stationary distribution constraint by giving a stationary vector as value. The estimated count-
and transition-matrices are restricted to states that have positive entries. In case the vector is not
normalized, setting it here implicitly copies and normalizes it.</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray or None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<script src="../../_static/scrollbar.js"></script>

  </body>
</html>