
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>class MarkovStateModel &#8212; deeptime 0.4.1+2.g7179c1b3.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/perfect-scrollbar/css/perfect-scrollbar.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/perfect-scrollbar/js/perfect-scrollbar.min.js"></script>
    <script src="../../_static/perfect-scrollbar/js/perfect-scrollbar.min.js"></script>
    <script src="../../_static/d3.v5.min.js"></script>
    <script src="../../_static/d3-legend.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"></script>
    <script src="../../_static/katex_autorenderer.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="class MarkovStateModelCollection" href="deeptime.markov.msm.MarkovStateModelCollection.html" />
    <link rel="prev" title="class TRAM" href="deeptime.markov.msm.TRAM.html" />
<link rel="apple-touch-icon" sizes="180x180" href="../../_static/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../_static/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../_static/favicon-16x16.png">
<link rel="manifest" href="../../_static/site.webmanifest">

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo/deeptime_romand_white.svg" alt="Logo"/>
    
  </a>
</p>










<!-- h3>Navigation</h3 -->
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index_dimreduction.html">Dimension reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_deepdimreduction.html">Deep dim reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/sindy.html">SINDy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_msm.html">Markov state models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/hmm.html">Hidden Markov Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/clustering.html">Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datasets/index.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index_dev.html">For developers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index_base.html">deeptime.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_clustering.html">deeptime.clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_sindy.html">deeptime.sindy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_covariance.html">deeptime.covariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_decomposition.html">deeptime.decomposition</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index_markov.html">deeptime.markov</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#estimators">Estimators</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index_markov.html#models">Models</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#"><em>class</em> MarkovStateModel</a></li>
<li class="toctree-l3"><a class="reference internal" href="deeptime.markov.msm.MarkovStateModelCollection.html"><em>class</em> MarkovStateModelCollection</a></li>
<li class="toctree-l3"><a class="reference internal" href="deeptime.markov.msm.BayesianMSMPosterior.html"><em>class</em> BayesianMSMPosterior</a></li>
<li class="toctree-l3"><a class="reference internal" href="deeptime.markov.msm.TRAMModel.html"><em>class</em> TRAMModel</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#analysis-tools">Analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index_markov.html#utilities-and-alternatives">Utilities and alternatives</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../index_markov_hmm.html">deeptime.markov.hmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_markov_tools.html">deeptime.markov.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_basis.html">deeptime.basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_kernels.html">deeptime.kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_data.html">deeptime.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_plots.html">deeptime.plots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_numeric.html">deeptime.numeric</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index_util.html">deeptime.util</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../imprint.html">Imprint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">Software License</a></li>
</ul>





<!--
<p>
    <iframe src="https://ghbtns.com/github-btn.html?user=deeptime-ml&repo=deeptime&type=star&count=true&size=large&v=2"
            allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>
--><p class="caption">
    <span class="caption-text">Version</span>
</p>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" id="version-latest"
           href="../latest/../../index.html">Latest release
            (0.4.1)</a>
    </li>
    <li class="toctree-l1">
        <a class="reference internal" id="version-trunk"
           href="../trunk/../../index.html">Trunk version</a>
    </li>
</ul>
<script>
    if (window.location.href.indexOf("latest") > -1) {
        document.getElementById("version-latest").className = "reference internal current";
        document.getElementById("version-trunk").className = "reference internal";
    } else {
        document.getElementById("version-latest").className = "reference internal";
        document.getElementById("version-trunk").className = "reference internal current";
    }
</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index_markov.html">deeptime.markov</a><ul>
      <li>Previous: <a href="deeptime.markov.msm.TRAM.html" title="previous chapter"><em>class</em> TRAM</a></li>
      <li>Next: <a href="deeptime.markov.msm.MarkovStateModelCollection.html" title="next chapter"><em>class</em> MarkovStateModelCollection</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Quick search" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><div class="github-wrapper">
    <a href="https://github.com/deeptime-ml/deeptime"
       style="width: 16rem; height:100%; position:absolute; top:0; left:0;">
        <img class="side-logo logo-github" src="../../_static/GitHub-Mark-Light-32px.png" alt="gh"/>
        <div style="display: table; height: 100%; overflow: hidden;">
            <div style="display: table-cell; vertical-align: middle;">
                <div>deeptime &#64; GitHub
                </div>
            </div>
        </div>
    </a>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="class-markovstatemodel">
<h1><em>class</em> MarkovStateModel<a class="headerlink" href="#class-markovstatemodel" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">deeptime.markov.msm.</span></span><span class="sig-name descname"><span class="pre">MarkovStateModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stationary_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_eigenvalues</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_matrix_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lagtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Markov model with a given transition matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>(</em><em>n</em><em>,</em><em>n</em><em>) </em><em>array_like</em>) – The transition matrix.</p></li>
<li><p><strong>stationary_distribution</strong> (<em>ndarray</em><em>(</em><em>n</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Stationary distribution. Can be optionally given in case if it was already computed.</p></li>
<li><p><strong>reversible</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Whether the transition matrix is reversible with respect to its stationary distribution. If None (default),
will be determined from the transition matrix.</p></li>
<li><p><strong>n_eigenvalues</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – The number of eigenvalues / eigenvectors to be kept. If set to None, it depends on the transition matrix.
If it is densely stored (in terms of a numpy array), all eigenvectors and eigenvalues are computed. If it is
sparse, only the 10 largest eigenvalues with corresponding eigenvectors are computed.</p></li>
<li><p><strong>ncv</strong> (<em>int optional</em><em>, </em><em>default=None</em>) – Relevant for eigenvalue decomposition of reversible transition matrices. It is the number of Lanczos
vectors generated, <cite>ncv</cite> must be greater than n_eigenvalues; it is recommended that ncv &gt; 2*neig.</p></li>
<li><p><strong>count_model</strong> (<a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov.TransitionCountModel"><em>TransitionCountModel</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – In case the MSM was estimated from data, the transition count model can be provided for statistical
information about the data. Some properties of the model require a count model so that they can be computed.</p></li>
<li><p><strong>transition_matrix_tolerance</strong> (<em>float</em><em>, </em><em>default=1e-8</em>) – The tolerance under which a matrix is still considered a transition matrix (only non-negative elements and
row sums of 1).</p></li>
<li><p><strong>lagtime</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – The lagtime of this MSM. If there is a count model, the MSM assumes the lagtime of the count model, otherwise
falls back to the lagtime set via this constructor argument or a lagtime of <cite>1</cite> if no lagtime is provided
at all.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="deeptime.markov.msm.MaximumLikelihoodMSM.html#deeptime.markov.msm.MaximumLikelihoodMSM" title="deeptime.markov.msm.MaximumLikelihoodMSM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaximumLikelihoodMSM</span></code></a></dt><dd><p>maximum-likelihood estimator for MSMs</p>
</dd>
<dt><a class="reference internal" href="deeptime.markov.msm.OOMReweightedMSM.html#deeptime.markov.msm.OOMReweightedMSM" title="deeptime.markov.msm.OOMReweightedMSM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OOMReweightedMSM</span></code></a></dt><dd><p>estimator for MSMs which uses Koopman reweighting</p>
</dd>
<dt><a class="reference internal" href="deeptime.markov.msm.BayesianMSM.html#deeptime.markov.msm.BayesianMSM" title="deeptime.markov.msm.BayesianMSM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BayesianMSM</span></code></a></dt><dd><p>bayesian sampling of MSMs to obtain uncertainties</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p id="id1"><dl class="citation">
<dt class="label" id="id25"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id76">2</a>,<a href="#id82">3</a>)</span></dt>
<dd><p>Frank Noé, Hao Wu, Jan-Hendrik Prinz, and Nuria Plattner. Projected and hidden markov models for calculating kinetics and metastable states of complex molecules. <em>The Journal of chemical physics</em>, 139(18):11B609_1, 2013.</p>
</dd>
<dt class="label" id="id24"><span class="brackets">2</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id77">2</a>,<a href="#id83">3</a>)</span></dt>
<dd><p>Susanna Röblitz and Marcus Weber. Fuzzy spectral clustering by pcca+: application to markov state models and data classification. <em>Advances in Data Analysis and Classification</em>, 7(2):147–179, 2013.</p>
</dd>
<dt class="label" id="id31"><span class="brackets">3</span><span class="fn-backref">(<a href="#id78">1</a>,<a href="#id80">2</a>,<a href="#id81">3</a>)</span></dt>
<dd><p>Frank Noé, Sören Doose, Isabella Daidone, Marc Löllmann, Markus Sauer, John D Chodera, and Jeremy C Smith. Dynamical fingerprints for probing individual relaxation processes in biomolecular dynamics with simulations and kinetic experiments. <em>Proceedings of the National Academy of Sciences</em>, 108(12):4822–4827, 2011.</p>
</dd>
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id79">4</a></span></dt>
<dd><p>Benjamin Lindner, Zheng Yi, Jan-Hendrik Prinz, Jeremy C Smith, and Frank Noé. Dynamic neutron scattering from conformational dynamics. i. theory and markov models. <em>The Journal of chemical physics</em>, 139(17):11B602_1, 2013.</p>
</dd>
<dt class="label" id="id17"><span class="brackets">5</span><span class="fn-backref">(<a href="#id84">1</a>,<a href="#id86">2</a>)</span></dt>
<dd><p>Frank Noé and Feliks Nüske. A variational approach to modeling slow processes in stochastic dynamical systems. <em>Multiscale Modeling &amp; Simulation</em>, 11(2):635–655, 2013.</p>
</dd>
<dt class="label" id="id15"><span class="brackets">6</span><span class="fn-backref">(<a href="#id85">1</a>,<a href="#id87">2</a>,<a href="#id89">3</a>,<a href="#id91">4</a>)</span></dt>
<dd><p>Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. <em>Journal of Nonlinear Science</em>, 30(1):23–66, 2020.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id88">7</a></span></dt>
<dd><p>Robert T McGibbon and Vijay S Pande. Variational cross-validation of slow dynamical modes in molecular kinetics. <em>The Journal of chemical physics</em>, 142(12):03B621_1, 2015.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id90">8</a></span></dt>
<dd><p>Frank Noé and Cecilia Clementi. Kinetic distance and kinetic maps from molecular dynamics simulation. <em>Journal of chemical theory and computation</em>, 11(10):5002–5011, 2015.</p>
</dd>
</dl>
</p>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.count_model" title="deeptime.markov.msm.MarkovStateModel.count_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_model</span></code></a></p></td>
<td><p>Returns a transition count model, can be None.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.empirical_koopman_model" title="deeptime.markov.msm.MarkovStateModel.empirical_koopman_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empirical_koopman_model</span></code></a></p></td>
<td><p>Yields a <code class="xref py py-class docutils literal notranslate"><span class="pre">CovarianceKoopmanModel</span></code> based on the count matrix of this Markov state model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.has_count_model" title="deeptime.markov.msm.MarkovStateModel.has_count_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_count_model</span></code></a></p></td>
<td><p>Yields whether this Markov state model has a count model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.is_real" title="deeptime.markov.msm.MarkovStateModel.is_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_real</span></code></a></p></td>
<td><p>Checks if all eigenvalues as well as eigenvectors/functions are real.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.koopman_model" title="deeptime.markov.msm.MarkovStateModel.koopman_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">koopman_model</span></code></a></p></td>
<td><p>Yields a <code class="xref py py-class docutils literal notranslate"><span class="pre">CovarianceKoopmanModel</span></code> based on the transition matrix and stationary</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.lagtime" title="deeptime.markov.msm.MarkovStateModel.lagtime"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lagtime</span></code></a></p></td>
<td><p>The lagtime this model was estimated at.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.n_eigenvalues" title="deeptime.markov.msm.MarkovStateModel.n_eigenvalues"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_eigenvalues</span></code></a></p></td>
<td><p>number of eigenvalues to compute.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.n_states" title="deeptime.markov.msm.MarkovStateModel.n_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_states</span></code></a></p></td>
<td><p>Number of active states on which all computations and estimations are done</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.ncv" title="deeptime.markov.msm.MarkovStateModel.ncv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ncv</span></code></a></p></td>
<td><p>Number of Lanczos vectors used when computing the partial eigenvalue decomposition</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.reversible" title="deeptime.markov.msm.MarkovStateModel.reversible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reversible</span></code></a></p></td>
<td><p>Returns whether the MarkovStateModel is reversible</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.sparse" title="deeptime.markov.msm.MarkovStateModel.sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse</span></code></a></p></td>
<td><p>Returns whether the MarkovStateModel is sparse</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.stationary" title="deeptime.markov.msm.MarkovStateModel.stationary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stationary</span></code></a></p></td>
<td><p>Whether the MSM is stationary, i.e. whether the initial distribution is the stationary distribution of the hidden transition matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.stationary_distribution" title="deeptime.markov.msm.MarkovStateModel.stationary_distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stationary_distribution</span></code></a></p></td>
<td><p>The stationary distribution on the MarkovStateModel states</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.transition_matrix" title="deeptime.markov.msm.MarkovStateModel.transition_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transition_matrix</span></code></a></p></td>
<td><p>The transition matrix on the active set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.transition_matrix_tolerance" title="deeptime.markov.msm.MarkovStateModel.transition_matrix_tolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transition_matrix_tolerance</span></code></a></p></td>
<td><p>The tolerance under which a matrix is considered a transition matrix.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.ck_test" title="deeptime.markov.msm.MarkovStateModel.ck_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ck_test</span></code></a>(models, n_metastable_sets[, ...])</p></td>
<td><p>Validates a model estimated at lag time tau by testing its predictions for longer lag times.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.committor_backward" title="deeptime.markov.msm.MarkovStateModel.committor_backward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">committor_backward</span></code></a>(A, B)</p></td>
<td><p>Backward committor from set A to set B</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.committor_forward" title="deeptime.markov.msm.MarkovStateModel.committor_forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">committor_forward</span></code></a>(A, B)</p></td>
<td><p>Forward committor (also known as p_fold or splitting probability) from set A to set B.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.compute_state_indices" title="deeptime.markov.msm.MarkovStateModel.compute_state_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_state_indices</span></code></a>(dtrajs)</p></td>
<td><p>Generates a trajectory/time indices for the given list of states.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.compute_trajectory_weights" title="deeptime.markov.msm.MarkovStateModel.compute_trajectory_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_trajectory_weights</span></code></a>(dtrajs)</p></td>
<td><p>Uses the MarkovStateModel to assign a probability weight to each trajectory frame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.copy" title="deeptime.markov.msm.MarkovStateModel.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Makes a deep copy of this model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.correlation" title="deeptime.markov.msm.MarkovStateModel.correlation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation</span></code></a>(a[, b, maxtime, k, ncv])</p></td>
<td><p>Time-correlation for equilibrium experiment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.eigenvalues" title="deeptime.markov.msm.MarkovStateModel.eigenvalues"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvalues</span></code></a>([k])</p></td>
<td><p>Compute or fetch the transition matrix eigenvalues.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.eigenvectors_left" title="deeptime.markov.msm.MarkovStateModel.eigenvectors_left"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvectors_left</span></code></a>([k])</p></td>
<td><p>Compute the left transition matrix eigenvectors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.eigenvectors_right" title="deeptime.markov.msm.MarkovStateModel.eigenvectors_right"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvectors_right</span></code></a>([k])</p></td>
<td><p>Compute the right transition matrix eigenvectors</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.expectation" title="deeptime.markov.msm.MarkovStateModel.expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code></a>(a)</p></td>
<td><p>Equilibrium expectation value of a given observable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.fingerprint_correlation" title="deeptime.markov.msm.MarkovStateModel.fingerprint_correlation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fingerprint_correlation</span></code></a>(a[, b, k, ncv])</p></td>
<td><p>Dynamical fingerprint for equilibrium time-correlation experiment.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.fingerprint_relaxation" title="deeptime.markov.msm.MarkovStateModel.fingerprint_relaxation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fingerprint_relaxation</span></code></a>(p0, a[, k, ncv])</p></td>
<td><p>Dynamical fingerprint for perturbation/relaxation experiment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.get_params" title="deeptime.markov.msm.MarkovStateModel.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</p></td>
<td><p>Get the parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.hmm" title="deeptime.markov.msm.MarkovStateModel.hmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hmm</span></code></a>(dtrajs, nhidden[, return_estimator])</p></td>
<td><p>Estimates a hidden Markov state model as described in <span id="id76">[<a class="reference internal" href="#id25" title="Frank Noé, Hao Wu, Jan-Hendrik Prinz, and Nuria Plattner. Projected and hidden markov models for calculating kinetics and metastable states of complex molecules. The Journal of chemical physics, 139(18):11B609_1, 2013.">1</a>]</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.mfpt" title="deeptime.markov.msm.MarkovStateModel.mfpt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mfpt</span></code></a>(A, B)</p></td>
<td><p>Mean first passage times from set A to set B, in units of the input trajectory time step.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.pcca" title="deeptime.markov.msm.MarkovStateModel.pcca"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pcca</span></code></a>(n_metastable_sets)</p></td>
<td><p>Runs PCCA+ <span id="id77">[<a class="reference internal" href="#id24" title="Susanna Röblitz and Marcus Weber. Fuzzy spectral clustering by pcca+: application to markov state models and data classification. Advances in Data Analysis and Classification, 7(2):147–179, 2013.">2</a>]</span> to compute a metastable decomposition of MarkovStateModel states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.propagate" title="deeptime.markov.msm.MarkovStateModel.propagate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagate</span></code></a>(p0, k)</p></td>
<td><p>Propagates the initial distribution p0 k times</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.reactive_flux" title="deeptime.markov.msm.MarkovStateModel.reactive_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reactive_flux</span></code></a>(source_states, target_states)</p></td>
<td><p>A-&gt;B reactive flux from transition path theory (TPT)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.relaxation" title="deeptime.markov.msm.MarkovStateModel.relaxation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">relaxation</span></code></a>(p0, a[, maxtime, k, ncv])</p></td>
<td><p>Simulates a perturbation-relaxation experiment.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.score" title="deeptime.markov.msm.MarkovStateModel.score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">score</span></code></a>([dtrajs, r, dim])</p></td>
<td><p>Scores the MSM using the dtrajs using the variational approach for Markov processes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.set_params" title="deeptime.markov.msm.MarkovStateModel.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**params)</p></td>
<td><p>Set the parameters of this estimator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.simulate" title="deeptime.markov.msm.MarkovStateModel.simulate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">simulate</span></code></a>(n_steps[, start, stop, dt, seed])</p></td>
<td><p>Generates a realization of the Markov Model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.submodel" title="deeptime.markov.msm.MarkovStateModel.submodel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">submodel</span></code></a>(states)</p></td>
<td><p>Restricts this markov state model to a subset of states by taking a submatrix of the transition matrix and re-normalizing it, as well as restricting the stationary distribution and count model if given.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.timescales" title="deeptime.markov.msm.MarkovStateModel.timescales"><code class="xref py py-obj docutils literal notranslate"><span class="pre">timescales</span></code></a>([k])</p></td>
<td><p>Relaxation timescales corresponding to the eigenvalues.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.to_koopman_model" title="deeptime.markov.msm.MarkovStateModel.to_koopman_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_koopman_model</span></code></a>([empirical, epsilon])</p></td>
<td><p>Computes the SVD of the symmetrized Koopman operator in the analytical or empirical distribution, returns as Koopman model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.update_stationary_distribution" title="deeptime.markov.msm.MarkovStateModel.update_stationary_distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_stationary_distribution</span></code></a>(value)</p></td>
<td><p>Explicitly sets the stationary distribution, re-normalizes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.update_transition_matrix" title="deeptime.markov.msm.MarkovStateModel.update_transition_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_transition_matrix</span></code></a>(value)</p></td>
<td><p>Sets the transition matrix and invalidates all cached and derived properties.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.ck_test">
<span class="sig-name descname"><span class="pre">ck_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_metastable_sets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_lag0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_est</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.ck_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates a model estimated at lag time tau by testing its predictions for longer lag times.
This is known as the Chapman-Kolmogorov test as it is based on the Chapman-Kolmogorov equation.
The test is performed on metastable sets of states rather than the micro-states themselves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>models</strong> (<em>list of MarkovStateModel</em>) – A list of models which were estimated at different and in particular longer lagtimes.</p></li>
<li><p><strong>n_metastable_sets</strong> (<em>int</em>) – Number of metastable sets, estimated via <a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.pcca" title="deeptime.markov.msm.MarkovStateModel.pcca"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pcca()</span></code></a>.</p></li>
<li><p><strong>include_lag0</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – Whether to include a lagtime 0 in the test, which corresponds to an identity transition matrix for MSMs.</p></li>
<li><p><strong>err_est</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – Whether to compute errors on observable evaluations of the models in the models parameter.</p></li>
<li><p><strong>progress</strong> (<em>object</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Optional progress bar. Tested for tqdm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ck_test</strong> – A Chapman-Kolmogorov test object that can be used with <a class="reference internal" href="deeptime.plots.plot_ck_test.html#deeptime.plots.plot_ck_test" title="deeptime.plots.plot_ck_test"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_ck_test</span></code></a>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.util.validation.ChapmanKolmogorovTest.html#deeptime.util.validation.ChapmanKolmogorovTest" title="deeptime.util.validation.ChapmanKolmogorovTest">ChapmanKolmogorovTest</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="deeptime.util.validation.ck_test.html#deeptime.util.validation.ck_test" title="deeptime.util.validation.ck_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deeptime.util.validation.ck_test</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.committor_backward">
<span class="sig-name descname"><span class="pre">committor_backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.committor_backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Backward committor from set A to set B</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>int</em><em> or </em><em>int array</em>) – set of starting states</p></li>
<li><p><strong>B</strong> (<em>int</em><em> or </em><em>int array</em>) – set of target states</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.committor_forward">
<span class="sig-name descname"><span class="pre">committor_forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.committor_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward committor (also known as p_fold or splitting probability) from set A to set B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>int</em><em> or </em><em>int array</em>) – set of starting states</p></li>
<li><p><strong>B</strong> (<em>int</em><em> or </em><em>int array</em>) – set of target states</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.compute_state_indices">
<span class="sig-name descname"><span class="pre">compute_state_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtrajs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.compute_state_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a trajectory/time indices for the given list of states. If a count model is provided in this
MSM and it does not represent the full state space, the discrete trajectories are first mapped to the
active state space, inactive states are mapped to -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtrajs</strong> (<em>array_like</em><em> or </em><em>list of array_like</em>) – Discretized trajectories.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state_indices</strong> – A list of arrays with trajectory/time indices for the provided discretized trajectories.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List of ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.compute_trajectory_weights">
<span class="sig-name descname"><span class="pre">compute_trajectory_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtrajs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.compute_trajectory_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the MarkovStateModel to assign a probability weight to each trajectory frame.</p>
<p>This is a powerful function for the calculation of arbitrary observables in the trajectories one has
started the analysis with. The stationary probability of the MarkovStateModel will be used to reweigh all
states. Returns a list of weight arrays, one for each trajectory, and with a number of elements equal to
trajectory frames. Given <span class="math">\(N\)</span> trajectories of lengths <span class="math">\(T_1\)</span> to <span class="math">\(T_N\)</span>, this function
returns corresponding weights:</p>
<div class="math">
\[(w_{1,1}, ..., w_{1,T_1}), (w_{N,1}, ..., w_{N,T_N})\]</div>
<p>that are normalized to one:</p>
<div class="math">
\[\sum_{i=1}^N \sum_{t=1}^{T_i} w_{i,t} = 1\]</div>
<p>Suppose you are interested in computing the expectation value of a function <span class="math">\(a(x)\)</span>, where <span class="math">\(x\)</span>
are your input configurations. Use this function to compute the weights of all input configurations and
obtain the estimated expectation by:</p>
<div class="math">
\[\langle a \rangle = \sum_{i=1}^N \sum_{t=1}^{T_i} w_{i,t} a(x_{i,t})\]</div>
<p>Or if you are interested in computing the time-lagged correlation between functions <span class="math">\(a(x)\)</span> and
<span class="math">\(b(x)\)</span> you could do:</p>
<div class="math">
\[\langle a(t) b(t+\tau) \rangle_t = \sum_{i=1}^N \sum_{t=1}^{T_i} w_{i,t} a(x_{i,t}) a(x_{i,t+\tau})\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>weights</strong> – The normalized trajectory weights. Given <span class="math">\(N\)</span> trajectories of lengths <span class="math">\(T_1\)</span> to <span class="math">\(T_N\)</span>,
returns the corresponding weights:</p>
<div class="math">
\[(w_{1,1}, ..., w_{1,T_1}), (w_{N,1}, ..., w_{N,T_N})\]</div>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="deeptime.base.Model.html#deeptime.base.Model" title="deeptime.base.Model"><span class="pre">deeptime.base.Model</span></a></span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a deep copy of this model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new copy of this model.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>copy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.correlation">
<span class="sig-name descname"><span class="pre">correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-correlation for equilibrium experiment.</p>
<p>In order to simulate a time-correlation experiment (e.g. fluorescence
correlation spectroscopy <span id="id78">[<a class="reference internal" href="#id31" title="Frank Noé, Sören Doose, Isabella Daidone, Marc Löllmann, Markus Sauer, John D Chodera, and Jeremy C Smith. Dynamical fingerprints for probing individual relaxation processes in biomolecular dynamics with simulations and kinetic experiments. Proceedings of the National Academy of Sciences, 108(12):4822–4827, 2011.">3</a>]</span>, dynamical neutron
scattering <span id="id79">[<a class="reference internal" href="#id32" title="Benjamin Lindner, Zheng Yi, Jan-Hendrik Prinz, Jeremy C Smith, and Frank Noé. Dynamic neutron scattering from conformational dynamics. i. theory and markov models. The Journal of chemical physics, 139(17):11B602_1, 2013.">4</a>]</span>, …), first compute the mean values of your experimental
observable <span class="math">\(a\)</span> by MarkovStateModel state:</p>
<div class="math">
\[a_i = \frac{1}{N_i} \sum_{x_t \in S_i} f(x_t)\]</div>
<p>where <span class="math">\(S_i\)</span> is the set of configurations belonging to MarkovStateModel state
<span class="math">\(i\)</span> and <span class="math">\(f()\)</span> is a function that computes the experimental
observable of interest for configuration <span class="math">\(x_t\)</span>. If a cross-correlation
function is wanted, also apply the above computation to a second
experimental observable <span class="math">\(b\)</span>.</p>
<p>Then the accurate (i.e. without statistical error) autocorrelation
function of <span class="math">\(f(x_t)\)</span> given the Markov model is computed by
correlation(a), and the accurate cross-correlation function is computed
by correlation(a,b). This is done by evaluating the equation</p>
<div class="math">
\[\begin{aligned}
acf_a(k\tau)     &= \mathbf{a}^\top \mathrm{diag}(\boldsymbol{\pi}) \mathbf{P(\tau)}^k \mathbf{a} \\
ccf_{a,b}(k\tau) &= \mathbf{a}^\top \mathrm{diag}(\boldsymbol{\pi}) \mathbf{P(\tau)}^k \mathbf{b}
\end{aligned}\]</div>
<p>where <span class="math">\(acf\)</span> stands for autocorrelation function and <span class="math">\(ccf\)</span>
stands for cross-correlation function, <span class="math">\(\mathbf{P(\tau)}\)</span> is the
transition matrix at lag time <span class="math">\(\tau\)</span>, <span class="math">\(\boldsymbol{\pi}\)</span> is the
equilibrium distribution of <span class="math">\(\mathbf{P}\)</span>, and <span class="math">\(k\)</span> is the time index.</p>
<p>Note that instead of using this method you could generate a long
synthetic trajectory from the MarkovStateModel and then estimating the
time-correlation of your observable(s) directly from this trajectory.
However, there is no reason to do this because the present method
does that calculation without any sampling, and only in the limit of
an infinitely long synthetic trajectory the two results will agree
exactly. The correlation function computed by the present method still
has statistical uncertainty from the fact that the underlying MarkovStateModel
transition matrix has statistical uncertainty when being estimated from
data, but there is no additional (and unnecessary) uncertainty due to
synthetic trajectory generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Observable, represented as vector on state space</p></li>
<li><p><strong>maxtime</strong> (<em>int</em><em> or </em><em>float</em>) – Maximum time (in units of the input trajectory time step) until
which the correlation function will be evaluated.
Internally, the correlation function can only be computed in
integer multiples of the Markov model lag time, and therefore
the actual last time point will be computed at <span class="math">\(\mathrm{ceil}(\mathrm{maxtime} / \tau)\)</span>
By default (None), the maxtime will be set equal to the 5 times
the slowest relaxation time of the MarkovStateModel, because after this time
the signal is almost constant.</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Second observable, for cross-correlations</p></li>
<li><p><strong>k</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Number of eigenvalues and eigenvectors to use for computation.
This option is only relevant for sparse matrices and long times
for which an eigenvalue decomposition will be done instead of
using the matrix power.</p></li>
<li><p><strong>ncv</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Only relevant for sparse matrices and large lag times where the
relaxation will be computed using an eigenvalue decomposition.
The number of Lanczos vectors generated, <cite>ncv</cite> must be greater than k;
it is recommended that ncv &gt; 2*k.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>times</strong> (<em>ndarray (N)</em>) – Time points (in units of the input trajectory time step) at which
the correlation has been computed</p></li>
<li><p><strong>correlations</strong> (<em>ndarray (N)</em>) – Correlation values at given times</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This example computes the autocorrelation function of a simple observable
on a three-state Markov model and plots the result using matplotlib:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">deeptime.markov.msm</span> <span class="k">as</span> <span class="nn">msm</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">msm</span><span class="o">.</span><span class="n">MarkovStateModel</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span><span class="p">,</span> <span class="n">acf</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">acf</span><span class="p">)</span>  
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.eigenvalues">
<span class="sig-name descname"><span class="pre">eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute or fetch the transition matrix eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em>) – number of eigenvalues to be returned. By default will return all
available eigenvalues</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ts</strong> – transition matrix eigenvalues <span class="math">\(\lambda_i, i = 1, ..., k\)</span>.,
sorted by descending norm.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(k,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.eigenvectors_left">
<span class="sig-name descname"><span class="pre">eigenvectors_left</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.eigenvectors_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the left transition matrix eigenvectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em>) – number of eigenvectors to be returned. By default uses value of <a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.n_eigenvalues" title="deeptime.markov.msm.MarkovStateModel.n_eigenvalues"><code class="xref py py-attr docutils literal notranslate"><span class="pre">n_eigenvalues</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>L</strong> – left eigenvectors in a row matrix. l_ij is the j’th component of
the i’th left eigenvector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(k,n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.eigenvectors_right">
<span class="sig-name descname"><span class="pre">eigenvectors_right</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.eigenvectors_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the right transition matrix eigenvectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em>) – number of eigenvectors to be computed. By default uses value of <a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.n_eigenvalues" title="deeptime.markov.msm.MarkovStateModel.n_eigenvalues"><code class="xref py py-attr docutils literal notranslate"><span class="pre">n_eigenvalues</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – right eigenvectors in a column matrix. r_ij is the i’th component
of the j’th right eigenvector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(n,k)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.expectation">
<span class="sig-name descname"><span class="pre">expectation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Equilibrium expectation value of a given observable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Observable vector on the MarkovStateModel state space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>val</strong> – Equilibrium expectation value fo the given observable</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The equilibrium expectation value of an observable <span class="math">\(a\)</span> is defined as follows</p>
<div class="math">
\[\mathbb{E}_{\mu}[a] = \sum_i \pi_i a_i\]</div>
<p><span class="math">\(\pi=(\pi_i)\)</span> is the stationary vector of the transition matrix <span class="math">\(P\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.fingerprint_correlation">
<span class="sig-name descname"><span class="pre">fingerprint_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.fingerprint_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamical fingerprint for equilibrium time-correlation experiment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Observable, represented as vector on MarkovStateModel state space</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>optional</em>) – Second observable, for cross-correlations</p></li>
<li><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues and eigenvectors to use for computation. This
option is only relevant for sparse matrices and long times for which
an eigenvalue decomposition will be done instead of using the matrix
power</p></li>
<li><p><strong>ncv</strong> (<em>int</em><em>, </em><em>optional</em>) – Only relevant for sparse matrices and large lag times, where the
relaxation will be computed using an eigenvalue decomposition.
The number of Lanczos vectors generated, <cite>ncv</cite> must be greater than k;
it is recommended that ncv &gt; 2*k</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>timescales</strong> (<em>(k,) ndarray</em>) – Time-scales (in units of the input trajectory time step) of the transition matrix</p></li>
<li><p><strong>amplitudes</strong> (<em>(k,) ndarray</em>) – Amplitudes for the correlation experiment</p></li>
<li><p><em>Spectral densities are commonly used in spectroscopy. Dynamical</em></p></li>
<li><p><em>fingerprints are a useful representation for computational</em></p></li>
<li><p>spectroscopy results and have been introduced in <span id="id80">[<a class="reference internal" href="#id31" title="Frank Noé, Sören Doose, Isabella Daidone, Marc Löllmann, Markus Sauer, John D Chodera, and Jeremy C Smith. Dynamical fingerprints for probing individual relaxation processes in biomolecular dynamics with simulations and kinetic experiments. Proceedings of the National Academy of Sciences, 108(12):4822–4827, 2011.">3</a>]</span>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.fingerprint_relaxation">
<span class="sig-name descname"><span class="pre">fingerprint_relaxation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.fingerprint_relaxation" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamical fingerprint for perturbation/relaxation experiment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p0</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Initial distribution for a relaxation experiment</p></li>
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Observable, represented as vector on state space</p></li>
<li><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues and eigenvectors to use for computation</p></li>
<li><p><strong>ncv</strong> (<em>int</em><em>, </em><em>optional</em>) – Only relevant for sparse matrices and large lag times, where the relaxation will be computes using an
eigenvalue decomposition. The number of Lanczos vectors generated, <cite>ncv</cite> must be greater than k;
it is recommended that ncv &gt; 2*k</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>timescales</strong> (<em>(k,) ndarray</em>) – Time-scales (in units of the input trajectory time step) of the transition matrix</p></li>
<li><p><strong>amplitudes</strong> (<em>(k,) ndarray</em>) – Amplitudes for the relaxation experiment</p></li>
<li><p><em>Spectral densities are commonly used in spectroscopy. Dynamical fingerprints are a useful representation</em></p></li>
<li><p>for computational spectroscopy results and have been introduced in <span id="id81">[<a class="reference internal" href="#id31" title="Frank Noé, Sören Doose, Isabella Daidone, Marc Löllmann, Markus Sauer, John D Chodera, and Jeremy C Smith. Dynamical fingerprints for probing individual relaxation processes in biomolecular dynamics with simulations and kinetic experiments. Proceedings of the National Academy of Sciences, 108(12):4822–4827, 2011.">3</a>]</span>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>params</strong> – Parameter names mapped to their values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mapping of string to any</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.hmm">
<span class="sig-name descname"><span class="pre">hmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtrajs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nhidden</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.hmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates a hidden Markov state model as described in <span id="id82">[<a class="reference internal" href="#id25" title="Frank Noé, Hao Wu, Jan-Hendrik Prinz, and Nuria Plattner. Projected and hidden markov models for calculating kinetics and metastable states of complex molecules. The Journal of chemical physics, 139(18):11B609_1, 2013.">1</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtrajs</strong> (<em>list of int-array like</em>) – discrete trajectories to use for estimation of the HMM.</p></li>
<li><p><strong>nhidden</strong> (<em>int</em>) – number of hidden (metastable) states</p></li>
<li><p><strong>return_estimator</strong> (<em>boolean</em><em>, </em><em>optional</em>) – if False only the Model is returned,
if True both the Estimator and the Model is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hmm</strong> – A hidden markov model.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.markov.hmm.HiddenMarkovModel.html#deeptime.markov.hmm.HiddenMarkovModel" title="deeptime.markov.hmm.HiddenMarkovModel">deeptime.markov.hmm.HiddenMarkovModel</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.mfpt">
<span class="sig-name descname"><span class="pre">mfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.mfpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean first passage times from set A to set B, in units of the input trajectory time step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>int</em><em> or </em><em>int array</em>) – set of starting states</p></li>
<li><p><strong>B</strong> (<em>int</em><em> or </em><em>int array</em>) – set of target states</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.pcca">
<span class="sig-name descname"><span class="pre">pcca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_metastable_sets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="deeptime.markov.PCCAModel.html#deeptime.markov.PCCAModel" title="deeptime.markov._pcca.PCCAModel"><span class="pre">deeptime.markov._pcca.PCCAModel</span></a></span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.pcca" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs PCCA+ <span id="id83">[<a class="reference internal" href="#id24" title="Susanna Röblitz and Marcus Weber. Fuzzy spectral clustering by pcca+: application to markov state models and data classification. Advances in Data Analysis and Classification, 7(2):147–179, 2013.">2</a>]</span> to compute a metastable decomposition of
MarkovStateModel states.</p>
<p>After calling this method you can access <code class="xref py py-func docutils literal notranslate"><span class="pre">metastable_memberships()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">metastable_distributions()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">metastable_sets()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">metastable_assignments()</span></code> of the returned object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_metastable_sets</strong> (<em>int</em>) – Number of metastable sets</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pcca_obj</strong> – An object containing all PCCA+ quantities.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.markov.PCCAModel.html#deeptime.markov.PCCAModel" title="deeptime.markov.PCCAModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCCAModel</span></code></a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If you coarse grain with PCCA+, the order of the obtained memberships
might not be preserved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagates the initial distribution p0 k times</p>
<p>Computes the product</p>
<div class="math">
\[p_k = p_0^T P^k\]</div>
<p>If the lag time of transition matrix <span class="math">\(P\)</span> is <span class="math">\(\tau\)</span>, this
will provide the probability distribution at time <span class="math">\(k \tau\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p0</strong> (<em>ndarray</em><em>(</em><em>n</em><em>,</em><em>)</em>) – Initial distribution. Vector of size of the active set.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of time steps</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pk</strong> – Distribution after k steps. Vector of size of the active set.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(n,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.reactive_flux">
<span class="sig-name descname"><span class="pre">reactive_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_states</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="deeptime.markov.ReactiveFlux.html#deeptime.markov.ReactiveFlux" title="deeptime.markov._reactive_flux.ReactiveFlux"><span class="pre">deeptime.markov._reactive_flux.ReactiveFlux</span></a></span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.reactive_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>A-&gt;B reactive flux from transition path theory (TPT)</p>
<p>The returned object can be used to extract various quantities of the flux, as well as to
compute A -&gt; B transition pathways, their weights, and to coarse-grain
the flux onto sets of states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_states</strong> (<em>array_like</em>) – List of integer state labels for set A</p></li>
<li><p><strong>target_states</strong> (<em>array_like</em>) – List of integer state labels for set B</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tptobj</strong> – An object containing the reactive A-&gt;B flux network
and several additional quantities, such as the stationary probability,
committors and set definitions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.markov.ReactiveFlux.html#deeptime.markov.ReactiveFlux" title="deeptime.markov.ReactiveFlux">ReactiveFlux</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">ReactiveFlux</span></code></dt><dd><p>Reactive Flux model</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.relaxation">
<span class="sig-name descname"><span class="pre">relaxation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.relaxation" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulates a perturbation-relaxation experiment.</p>
<p>In perturbation-relaxation experiments such as temperature-jump, pH-jump, pressure jump or rapid mixing
experiments, an ensemble of molecules is initially prepared in an off-equilibrium distribution and the
expectation value of some experimental observable is then followed over time as the ensemble relaxes towards
equilibrium.</p>
<p>In order to simulate such an experiment, first determine the distribution of states at which the experiment is
started, <span class="math">\(p_0\)</span> and compute the mean values of your experimental observable <span class="math">\(a\)</span>
by MarkovStateModel state:</p>
<div class="math">
\[a_i = \frac{1}{N_i} \sum_{x_t \in S_i} f(x_t)\]</div>
<p>where <span class="math">\(S_i\)</span> is the set of configurations belonging to MarkovStateModel state <span class="math">\(i\)</span>
and <span class="math">\(f()\)</span> is a function that computes the experimental observable of
interest for configuration <span class="math">\(x_t\)</span>.</p>
<p>Then the accurate (i.e. without statistical error) time-dependent expectation value of <span class="math">\(f(x_t)\)</span> given the
Markov model is computed by relaxation(p0, a). This is done by evaluating the equation</p>
<div class="math">
\[E_a(k\tau) = \mathbf{p_0}^{\top} \mathbf{P(\tau)}^k \mathbf{a}\]</div>
<p>where <span class="math">\(E\)</span> stands for the expectation value that relaxes to its equilibrium value that is identical
to expectation(a), <span class="math">\(\mathbf{P(\tau)}\)</span> is the transition matrix at lag time <span class="math">\(\tau\)</span>,
<span class="math">\(\boldsymbol{\pi}\)</span> is the equilibrium distribution of <span class="math">\(\mathbf{P}\)</span>, and <span class="math">\(k\)</span> is the time index.</p>
<p>Note that instead of using this method you could generate many synthetic trajectory from the MarkovStateModel
with starting points drawn from the initial distribution and then estimating the
time-dependent expectation value by an ensemble average. However, there is no reason to do this because the
present method does that calculation without any sampling, and only in the limit of an infinitely many
trajectories the two results will agree exactly. The relaxation function computed by the present method still
has statistical uncertainty from the fact that the underlying MarkovStateModel transition
matrix has statistical uncertainty when being estimated from data, but there is no additional (and unnecessary)
uncertainty due to synthetic trajectory generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p0</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Initial distribution for a relaxation experiment</p></li>
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>ndarray</em>) – Observable, represented as vector on state space</p></li>
<li><p><strong>maxtime</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>optional</em>) – Maximum time (in units of the input trajectory time step) until which the correlation function will be
evaluated. Internally, the correlation function can only be computed in integer multiples of the
Markov model lag time, and therefore the actual last time point will be computed at
<span class="math">\(\mathrm{ceil}(\mathrm{maxtime} / \tau)\)</span>.
By default (None), the maxtime will be set equal to the 5 times the slowest relaxation time of the
MarkovStateModel, because after this time the signal is constant.</p></li>
<li><p><strong>k</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Number of eigenvalues and eigenvectors to use for computation</p></li>
<li><p><strong>ncv</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Only relevant for sparse matrices and large lag times, where the relaxation will be computes using an
eigenvalue decomposition.
The number of Lanczos vectors generated, <cite>ncv</cite> must be greater than k; it is recommended that ncv &gt; 2*k</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>times</strong> (<em>ndarray (N)</em>) – Time points (in units of the input trajectory time step) at which the relaxation has been computed</p></li>
<li><p><strong>res</strong> (<em>ndarray</em>) – Array of expectation value at given times</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.score">
<span class="sig-name descname"><span class="pre">score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtrajs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Scores the MSM using the dtrajs using the variational approach for Markov processes.</p>
<p>Implemented according to <span id="id84">[<a class="reference internal" href="#id17" title="Frank Noé and Feliks Nüske. A variational approach to modeling slow processes in stochastic dynamical systems. Multiscale Modeling &amp; Simulation, 11(2):635–655, 2013.">5</a>]</span> and <span id="id85">[<a class="reference internal" href="#id15" title="Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. Journal of Nonlinear Science, 30(1):23–66, 2020.">6</a>]</span>.</p>
<p>Currently only implemented using dense matrices - will be slow for large state spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtrajs</strong> (<em>list of arrays</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Test data (discrete trajectories). Note that if the test data contains states which are not
represented in this model, they are ignored.</p></li>
<li><p><strong>r</strong> (<em>float</em><em> or </em><em>str</em><em>, </em><em>optional</em><em>, </em><em>default=2</em>) – <p>Overwrite scoring method to be used if desired. Can be any float greater or equal 1 or ‘E’ for VAMP-r score
or VAMP-E score, respectively.</p>
<p>Special cases <span id="id86">[<a class="reference internal" href="#id17" title="Frank Noé and Feliks Nüske. A variational approach to modeling slow processes in stochastic dynamical systems. Multiscale Modeling &amp; Simulation, 11(2):635–655, 2013.">5</a>]</span> <span id="id87">[<a class="reference internal" href="#id15" title="Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. Journal of Nonlinear Science, 30(1):23–66, 2020.">6</a>]</span>:</p>
<ul>
<li><p>’VAMP1’: Sum of singular values of the symmetrized transition matrix.
If the MSM is reversible, this is equal to the sum of transition
matrix eigenvalues, also called Rayleigh quotient <span id="id88">[<a class="reference internal" href="#id19" title="Robert T McGibbon and Vijay S Pande. Variational cross-validation of slow dynamical modes in molecular kinetics. The Journal of chemical physics, 142(12):03B621_1, 2015.">7</a>]</span>.</p></li>
<li><p>’VAMP2’: Sum of squared singular values of the symmetrized  transition matrix
<span id="id89">[<a class="reference internal" href="#id15" title="Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. Journal of Nonlinear Science, 30(1):23–66, 2020.">6</a>]</span>. If the MSM is reversible, this is equal to the
kinetic variance <span id="id90">[<a class="reference internal" href="#id10" title="Frank Noé and Cecilia Clementi. Kinetic distance and kinetic maps from molecular dynamics simulation. Journal of chemical theory and computation, 11(10):5002–5011, 2015.">8</a>]</span>.</p></li>
<li><p>’VAMPE’: Approximation error of the estimated Koopman operator with respect to the true Koopman operator
up to an additive constant <span id="id91">[<a class="reference internal" href="#id15" title="Hao Wu and Frank Noé. Variational approach for learning markov processes from time series data. Journal of Nonlinear Science, 30(1):23–66, 2020.">6</a>]</span>.</p></li>
</ul>
</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – The maximum number of eigenvalues or singular values used in the
score. If set to None, all available eigenvalues will be used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal notranslate"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**params</strong> (<em>dict</em>) – Estimator parameters.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Estimator instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.simulate">
<span class="sig-name descname"><span class="pre">simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a realization of the Markov Model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_steps</strong> (<em>int</em>) – trajectory length in steps of the lag time</p></li>
<li><p><strong>start</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default = None</em>) – starting state</p></li>
<li><p><strong>stop</strong> (<em>int</em><em> or </em><em>int-array-like</em><em>, </em><em>optional</em><em>, </em><em>default = None</em>) – stopping hidden set. If given, the trajectory will be stopped before
N steps once a hidden state of the stop set is reached</p></li>
<li><p><strong>dt</strong> (<em>int</em><em>, </em><em>default=1</em>) – trajectory will be saved every dt time steps.
Internally, the dt’th power of P is taken to ensure a more efficient simulation.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default=-1</em>) – If non-negative, this fixes the seed used for sampling to the provided value so that
results are reproducible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The state trajectory with length N/dt</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(N/dt,) ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msm</span> <span class="o">=</span> <span class="n">MarkovStateModel</span><span class="p">(</span><span class="n">transition_matrix</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">.7</span><span class="p">,</span> <span class="mf">.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">.3</span><span class="p">,</span> <span class="mf">.7</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">msm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>  
<span class="go">[...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.submodel">
<span class="sig-name descname"><span class="pre">submodel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.submodel" title="Permalink to this definition">¶</a></dt>
<dd><p>Restricts this markov state model to a subset of states by taking a submatrix of the transition matrix
and re-normalizing it, as well as restricting the stationary distribution and count model if given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>states</strong> (<em>array_like of int</em>) – states to restrict to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>submodel</strong> – A onto the given states restricted MSM.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel" title="deeptime.markov.msm.MarkovStateModel">MarkovStateModel</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.timescales">
<span class="sig-name descname"><span class="pre">timescales</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.timescales" title="Permalink to this definition">¶</a></dt>
<dd><p>Relaxation timescales corresponding to the eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Number of timescales to be returned. By default, this uses all available eigenvalues except for the
first (stationary) eigenvalue.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ts</strong> – Relaxation timescales in units of the input trajectory time step,
defined by <span class="math">\(-\tau / \mathrm{ln} | \lambda_i |, i = 2,...,k+1\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(m)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.to_koopman_model">
<span class="sig-name descname"><span class="pre">to_koopman_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">empirical</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.to_koopman_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the SVD of the symmetrized Koopman operator in the analytical or empirical distribution,
returns as Koopman model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>empirical</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – Determines whether the model should refer to the analytical distributions based on the transition matrix
or the empirical distributions based on the count matrix.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1e-10</em>) – Regularization parameter for computing inverses of covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – The model.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="deeptime.decomposition.CovarianceKoopmanModel.html#deeptime.decomposition.CovarianceKoopmanModel" title="deeptime.decomposition.CovarianceKoopmanModel">CovarianceKoopmanModel</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.update_stationary_distribution">
<span class="sig-name descname"><span class="pre">update_stationary_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.update_stationary_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly sets the stationary distribution, re-normalizes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.update_transition_matrix">
<span class="sig-name descname"><span class="pre">update_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.update_transition_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the transition matrix and invalidates all cached and derived properties.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.count_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">count_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov._transition_counting.TransitionCountModel"><span class="pre">deeptime.markov._transition_counting.TransitionCountModel</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.count_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a transition count model, can be None. The transition count model statistics about data that was used
for transition counting as well as a count matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – The transition count model or None.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="deeptime.markov.TransitionCountModel.html#deeptime.markov.TransitionCountModel" title="deeptime.markov.TransitionCountModel">TransitionCountModel</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.empirical_koopman_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">empirical_koopman_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="deeptime.decomposition.CovarianceKoopmanModel.html#deeptime.decomposition.CovarianceKoopmanModel" title="deeptime.decomposition._koopman.CovarianceKoopmanModel"><span class="pre">deeptime.decomposition._koopman.CovarianceKoopmanModel</span></a></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.empirical_koopman_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields a <code class="xref py py-class docutils literal notranslate"><span class="pre">CovarianceKoopmanModel</span></code> based on the count matrix of this Markov state model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – The model.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="deeptime.decomposition.CovarianceKoopmanModel.html#deeptime.decomposition.CovarianceKoopmanModel" title="deeptime.decomposition.CovarianceKoopmanModel">CovarianceKoopmanModel</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <span class="math">\(C\in\mathbb{R}^{n\times n}\)</span> denotes the count matrix and <span class="math">\(P\)</span> the transition matrix,
we define covariance matrices based on transition count statistics</p>
<div class="math">
\[\begin{aligned}
C_{00} &= \text{diag} \left( \sum_i C_{i1}, \ldots, \sum_i C_{in} \right) \\
C_{11} &= \text{diag} \left( \sum_i C_{1i}, \ldots, \sum_i C_{ni} \right) \\
C_{01} &= C,
\end{aligned}\]</div>
<p>and reweight the operator <span class="math">\(P\)</span> to the empirical distribution via <span class="math">\(C_{01\text{, re}} = C_{00}P\)</span>.
Based on these we define the Koopman operator <span class="math">\(K = C_{00}^{-1/2}C_{01\text{, re}}C_{11}^{-1/2}\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.to_koopman_model" title="deeptime.markov.msm.MarkovStateModel.to_koopman_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_koopman_model</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.has_count_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_count_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.has_count_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields whether this Markov state model has a count model.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.is_real">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_real</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.is_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if all eigenvalues as well as eigenvectors/functions are real.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.koopman_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">koopman_model</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="deeptime.decomposition.CovarianceKoopmanModel.html#deeptime.decomposition.CovarianceKoopmanModel" title="deeptime.decomposition._koopman.CovarianceKoopmanModel"><span class="pre">deeptime.decomposition._koopman.CovarianceKoopmanModel</span></a></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.koopman_model" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Yields a <code class="xref py py-class docutils literal notranslate"><span class="pre">CovarianceKoopmanModel</span></code> based on the transition matrix and stationary</dt><dd><p>distribution of this Markov state model.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – The model.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="deeptime.decomposition.CovarianceKoopmanModel.html#deeptime.decomposition.CovarianceKoopmanModel" title="deeptime.decomposition.CovarianceKoopmanModel">CovarianceKoopmanModel</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <span class="math">\(P\in\mathbb{R}^{n\times n}\)</span> denotes the transition matrix and <span class="math">\(\mu\in\mathbb{R}^n\)</span> denotes
the stationary distribution, we define covariance matrices</p>
<div class="math">
\[\begin{aligned}
C_{00} &= C_{11} = \text{diag} (\mu_1,\ldots,\mu_n)\\
C_{01} &= C_{00}P
\end{aligned}

\]</div>
<p>and based on these a Koopman operator <span class="math">\(K = C_{00}^{-1/2}C_{01}C_{11}^{-1/2}\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#deeptime.markov.msm.MarkovStateModel.to_koopman_model" title="deeptime.markov.msm.MarkovStateModel.to_koopman_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_koopman_model</span></code></a></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.lagtime">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lagtime</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.lagtime" title="Permalink to this definition">¶</a></dt>
<dd><p>The lagtime this model was estimated at. In case no count model was provided, this property defaults
to the lagtime set in the constructor or a lagtime of <span class="math">\(\tau = 1\)</span> if it was left <cite>None</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>lagtime</strong> – The lagtime.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.n_eigenvalues">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_eigenvalues</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.n_eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>number of eigenvalues to compute.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.n_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_states</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.n_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of active states on which all computations and estimations are done</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.ncv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ncv</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.ncv" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of Lanczos vectors used when computing the partial eigenvalue decomposition</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.reversible">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">reversible</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.reversible" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the MarkovStateModel is reversible</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.sparse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sparse</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the MarkovStateModel is sparse</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.stationary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stationary</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.stationary" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the MSM is stationary, i.e. whether the initial distribution is the stationary distribution
of the hidden transition matrix.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.stationary_distribution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stationary_distribution</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.stationary_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>The stationary distribution on the MarkovStateModel states</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.transition_matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">transition_matrix</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.transition_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The transition matrix on the active set.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="deeptime.markov.msm.MarkovStateModel.transition_matrix_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">transition_matrix_tolerance</span></span><a class="headerlink" href="#deeptime.markov.msm.MarkovStateModel.transition_matrix_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>The tolerance under which a matrix is considered a transition matrix. This means that all elements
must be non-negative and the row sums must be 1.</p>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<script src="../../_static/scrollbar.js"></script>

  </body>
</html>